import { formatDeliveryTimeRange } from 'path-to-your-file';
import * as utils from 'utils/moment-time-utils';

jest.mock('utils/moment-time-utils', () => ({
  ...jest.requireActual('utils/moment-time-utils'),
  getTimeZoneAbbr: jest.fn(),
  getBrowserTimeZone: jest.fn(),
  formatDate: jest.fn(),
  formatHoursRange: jest.fn(),
}));

describe('formatDeliveryTimeRange', () => {
  it('should return the formatted time when start and end time are the same', () => {
    const mockStart = '2025-02-17T08:00:00Z';
    const mockEnd = '2025-02-17T08:30:00Z';
    const mockTimezone = 'UTC';

    // Mocking helper functions
    (utils.getTimeZoneAbbr as jest.Mock).mockReturnValue('UTC');
    (utils.formatDate as jest.Mock).mockReturnValue('08');
    (utils.formatHoursRange as jest.Mock).mockReturnValue('08:00 - 08:30');

    const result = formatDeliveryTimeRange(mockStart, mockEnd, mockTimezone);
    expect(result).toBe('08:00 - 08:30');
  });

  it('should return the formatted time range when start and end times differ', () => {
    const mockStart = '2025-02-17T08:00:00Z';
    const mockEnd = '2025-02-17T09:00:00Z';
    const mockTimezone = 'UTC';

    // Mocking helper functions
    (utils.getTimeZoneAbbr as jest.Mock).mockReturnValue('UTC');
    (utils.formatDate as jest.Mock).mockReturnValue('08');
    (utils.formatHoursRange as jest.Mock).mockReturnValue('08:00 - 09:00');

    const result = formatDeliveryTimeRange(mockStart, mockEnd, mockTimezone);
    expect(result).toBe('08:00 - 09:00');
  });
});




import { sortTripsByStartDateTime } from 'path-to-your-file';
import { Trip } from 'types/spark-driver/trip.types';

describe('sortTripsByStartDateTime', () => {
  it('should sort trips by start date time in descending order', () => {
    const trips: Trip[] = [
      { tripStartDateTime: '2025-02-17T08:00:00Z' },
      { tripStartDateTime: '2025-02-16T08:00:00Z' },
      { tripStartDateTime: '2025-02-18T08:00:00Z' },
    ];

    const sortedTrips = sortTripsByStartDateTime(trips);
    expect(sortedTrips[0].tripStartDateTime).toBe('2025-02-18T08:00:00Z');
    expect(sortedTrips[1].tripStartDateTime).toBe('2025-02-17T08:00:00Z');
    expect(sortedTrips[2].tripStartDateTime).toBe('2025-02-16T08:00:00Z');
  });
});


import { sortOrdersByCustomerStartTime } from 'path-to-your-file';
import { DeliveryTask } from 'types/spark-driver/trip.types';

describe('sortOrdersByCustomerStartTime', () => {
  it('should sort orders by customer start time in descending order', () => {
    const orders: DeliveryTask[] = [
      { customerStartTime: '2025-02-17T08:00:00Z' },
      { customerStartTime: '2025-02-16T08:00:00Z' },
      { customerStartTime: '2025-02-18T08:00:00Z' },
    ];

    const sortedOrders = sortOrdersByCustomerStartTime(orders);
    expect(sortedOrders[0].customerStartTime).toBe('2025-02-18T08:00:00Z');
    expect(sortedOrders[1].customerStartTime).toBe('2025-02-17T08:00:00Z');
    expect(sortedOrders[2].customerStartTime).toBe('2025-02-16T08:00:00Z');
  });
});


import { groupAndSortDeliveryTasks } from 'path-to-your-file';
import { DeliveryTask } from 'types/spark-driver/trip.types';

describe('groupAndSortDeliveryTasks', () => {
  it('should group and sort tasks by storeId and serviceType', () => {
    const tasks: DeliveryTask[] = [
      { storeId: 1, serviceType: 'A' },
      { storeId: 2, serviceType: 'B' },
      { storeId: 1, serviceType: 'A' },
    ];

    const result = groupAndSortDeliveryTasks(tasks);
    expect(result.groupedTasks['1A'].length).toBe(2);
    expect(result.groupedTasks['2B'].length).toBe(1);
    expect(result.sortingOrder).toEqual(['1A', '2B']);
  });
});


import { sortTripsAndGroupTasks } from 'path-to-your-file';
import { Trip, DeliveryTask } from 'types/spark-driver/trip.types';

describe('sortTripsAndGroupTasks', () => {
  it('should sort trips and group tasks correctly', () => {
    const trips: Trip[] = [
      {
        tripStartDateTime: '2025-02-17T08:00:00Z',
        deliveryTasks: [
          { storeId: 1, serviceType: 'A' },
          { storeId: 2, serviceType: 'B' },
        ],
      },
      {
        tripStartDateTime: '2025-02-18T08:00:00Z',
        deliveryTasks: [
          { storeId: 1, serviceType: 'A' },
          { storeId: 1, serviceType: 'B' },
        ],
      },
    ];

    const result = sortTripsAndGroupTasks(trips);
    expect(result.length).toBe(2);
    expect(result[0].tasksGroupedByStoreId['1A'].length).toBe(1);
  });
});


import { getTripTitleDate } from 'path-to-your-file';

describe('getTripTitleDate', () => {
  it('should return formatted date with timezone', () => {
    const mockDate = '2025-02-17T08:00:00Z';
    const result = getTripTitleDate(mockDate);
    expect(result).toBe('2025-02-17'); // Depending on the format used in utils
  });
});




import { getDeliveryType } from 'path-to-your-file';
import { DeliveryTask } from 'types/spark-driver/trip.types';
import { deliveryMapping } from 'constants/spark-driver/trip-constants';

jest.mock('constants/spark-driver/trip-constants', () => ({
  deliveryMapping: {
    'type1': jest.fn(),
    'type2': jest.fn(),
  },
}));

describe('getDeliveryType', () => {
  it('should return the correct delivery type', () => {
    const order: DeliveryTask = { storeId: 1, serviceType: 'A' };
    (deliveryMapping.type1 as jest.Mock).mockReturnValue(true);
    const result = getDeliveryType(order);
    expect(result).toBe('type1');
  });

  it('should return undefined if no match found', () => {
    const order: DeliveryTask = { storeId: 1, serviceType: 'C' };
    const result = getDeliveryType(order);
    expect(result).toBeUndefined();
  });
});


import { tripDisplayStatus, taskDisplayStatus } from 'path-to-your-file';

describe('tripDisplayStatus', () => {
  it('should return capitalized status', () => {
    const trip = { uiTripStatusDisplayText: 'completed' };
    const result = tripDisplayStatus(trip);
    expect(result).toBe('Completed');
  });
});

describe('taskDisplayStatus', () => {
  it('should return capitalized status', () => {
    const task = { statusDisplayTextLine1: 'in-progress' };
    const result = taskDisplayStatus(task);
    expect(result).toBe('In-progress');
  });
});

