import { renderHook } from '@testing-library/react-hooks';
import moment from 'moment';
import { usePaginatedTrips } from './usePaginatedTrips';  // Adjust the import path
import { SortedTrip } from 'types/spark-driver/trip.types';

const mockTrips: SortedTrip[] = [
  {
    tripStartDateTime: moment().startOf('day').toISOString(),
    tripEndDateTime: moment().endOf('day').toISOString(),
    id: '1',
  },
  {
    tripStartDateTime: moment().subtract(1, 'day').startOf('day').toISOString(),
    tripEndDateTime: moment().subtract(1, 'day').endOf('day').toISOString(),
    id: '2',
  },
  {
    tripStartDateTime: moment().subtract(2, 'days').startOf('day').toISOString(),
    tripEndDateTime: moment().subtract(2, 'days').endOf('day').toISOString(),
    id: '3',
  },
];

describe('usePaginatedTrips', () => {
  it('should return paginated trips for the first page', () => {
    const { result } = renderHook(() =>
      usePaginatedTrips(mockTrips, 1, 2)
    );

    expect(result.current.todayTrips).toEqual([mockTrips[0]]);
    expect(result.current.pastTrips).toEqual([mockTrips[1]]);
    expect(result.current.totalPages).toBe(2);
    expect(result.current.showTodayTripLabel).toBe(true);
    expect(result.current.showPastTripLabel).toBe(true);
  });

  it('should return only today\'s trips if they fit on one page', () => {
    const { result } = renderHook(() =>
      usePaginatedTrips([mockTrips[0]], 1, 2)
    );

    expect(result.current.todayTrips).toEqual([mockTrips[0]]);
    expect(result.current.pastTrips).toEqual([]);
    expect(result.current.totalPages).toBe(1);
    expect(result.current.showTodayTripLabel).toBe(true);
    expect(result.current.showPastTripLabel).toBe(false);
  });

  it('should return only past trips if today\'s trips do not fit on the page', () => {
    const { result } = renderHook(() =>
      usePaginatedTrips(mockTrips, 2, 1)
    );

    expect(result.current.todayTrips).toEqual([]);
    expect(result.current.pastTrips).toEqual([mockTrips[1]]);
    expect(result.current.totalPages).toBe(3);
    expect(result.current.showTodayTripLabel).toBe(false);
    expect(result.current.showPastTripLabel).toBe(true);
  });

  it('should correctly handle pagination for multiple pages', () => {
    const { result } = renderHook(() =>
      usePaginatedTrips(mockTrips, 2, 1)
    );

    expect(result.current.todayTrips).toEqual([]);
    expect(result.current.pastTrips).toEqual([mockTrips[1]]);
    expect(result.current.totalPages).toBe(3);
    expect(result.current.showTodayTripLabel).toBe(false);
    expect(result.current.showPastTripLabel).toBe(true);
  });

  it('should return no trips when given an empty list', () => {
    const { result } = renderHook(() =>
      usePaginatedTrips([], 1, 2)
    );

    expect(result.current.todayTrips).toEqual([]);
    expect(result.current.pastTrips).toEqual([]);
    expect(result.current.totalPages).toBe(0);
    expect(result.current.showTodayTripLabel).toBe(false);
    expect(result.current.showPastTripLabel).toBe(false);
  });

  it('should handle trips on the edge of the pagination range', () => {
    const { result } = renderHook(() =>
      usePaginatedTrips(mockTrips, 3, 1)
    );

    expect(result.current.todayTrips).toEqual([]);
    expect(result.current.pastTrips).toEqual([mockTrips[2]]);
    expect(result.current.totalPages).toBe(3);
    expect(result.current.showTodayTripLabel).toBe(false);
    expect(result.current.showPastTripLabel).toBe(true);
  });

  it('should handle exact pagination for all trips', () => {
    const { result } = renderHook(() =>
      usePaginatedTrips(mockTrips, 1, 3)
    );

    expect(result.current.todayTrips).toEqual([mockTrips[0]]);
    expect(result.current.pastTrips).toEqual([mockTrips[1], mockTrips[2]]);
    expect(result.current.totalPages).toBe(1);
    expect(result.current.showTodayTripLabel).toBe(true);
    expect(result.current.showPastTripLabel).toBe(false);
  });
});
